---
id: 487
title: 面试时候经常会问的一些问题(不断补充中)
date: 2010-08-02T17:36:00+00:00
author: 刘长炯
layout: post
guid: http://www.beansoft.biz/?p=487
permalink: '/2010/08/02/%e9%9d%a2%e8%af%95%e6%97%b6%e5%80%99%e7%bb%8f%e5%b8%b8%e4%bc%9a%e9%97%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98%e4%b8%8d%e6%96%ad%e8%a1%a5%e5%85%85%e4%b8%ad/'
views:
  - "8354"
original_post_id:
  - "487"
image: /wp-content/uploads/2012/09/None.gif
categories:
  - Java SE
---
面试必备基础题目(虽然不一定常用, 仅用于面试, 面试就是把人搞的都不会然后砍价, 当然您可以讲我可以查资料完成, 但是面试的时候就是没道理的, 起码我是经常看到这些题).

如何把一段逗号分割的字符串转换成一个数组?   
request.getAttribute() 和 request.getParameter() 有何区别?   
response.sendRedirect() 和 forward() 区别?   
<%@include file=&#8221;xxx.jsp&#8221;%>   
和 <jsp:include> 区别?   
List 和 Map 区别?   
Struts 和 Spring 自动填充表单参数到 Bean 的大致原理?   
说一下你用的 Spring + Hibernate 的方框图? 您都用到了哪些部分?

请用英文简单介绍一下自己.

请把 [http://tomcat.apache.org/](http://tomcat.apache.org/ "http://tomcat.apache.org/") 首页的这一段话用中文翻译一下?

> Apache Tomcat is the servlet container that is used in the official Reference Implementation for the [Java Servlet](http://java.sun.com/products/servlets) and [JavaServer Pages](http://java.sun.com/products/jsp) technologies. The Java Servlet and JavaServer Pages specifications are developed by Sun under the [Java Community Process](http://jcp.org/en/introduction/overview).
> 
> Apache Tomcat is developed in an open and participatory environment and released under the [Apache Software License](http://www.apache.org/licenses). Apache Tomcat is intended to be a collaboration of the best-of-breed developers from around the world. We invite you to participate in this open development project. To learn more about getting involved, [click here](http://tomcat.apache.org/getinvolved.html).
> 
> Apache Tomcat powers numerous large-scale, mission-critical web applications across a diverse range of industries and organizations. Some of these users and their stories are listed on the [PoweredBy](http://wiki.apache.org/tomcat/PoweredBy) wiki page.

try {   
Connection conn = &#8230;;   
Statement stmt = &#8230;;

ResultSet rs = stmt.executeQuery(&#8220;select * from table1&#8221;);

while(rs.next()) {

}   
} catch(Exception ex) {   
}

这段代码有什么不足之处?

HTML 的 form 提交之前如何验证数值不为空? 为空的话提示用户并终止提交?

为什么要用 ORM? 和 JDBC 有何不一样?

Weblogic 的 Server, Machine, Node, Domain 都有何区别?

简要讲一下 EJB 的 7 个 Transaction Level?

最常见的: 用 JDBC 查询学生成绩单, 把主要代码写出来.

Tomcat 5 用 query.jsp?name=中文, 怎么把这个变量无乱码的取出来?

[finally语句一定会执行么?](http://www.blogjava.net/daybug/archive/2007/03/12/103356.html)

前几天有一个朋友去面试,被问到这样一个问题,如下

1  <img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" align="top" height="16" width="11" />public class smallT   
2  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
3  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />public static void main(String args[])   
4  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
5  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />smallT t = new smallT();   
6  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />int b = t.get();   
7  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />System.out.println(b);   
8  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
9  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />public int get()   
10  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
11  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />try   
12  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
13  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />return 2 ;   
14  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
15  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />catch (Exception e)   
16  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
17  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />return 3 ;   
18  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
19  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />finally   
20  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
21  <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />return 4 ;   
22  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
23  <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
24 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif" align="top" height="16" width="11" />}   
25 <img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" align="top" height="16" width="11" />

输出：   
4   
我记得学习的时候说有返回值的方法,执行完return语句后就会停止了;另一方面我还记得在try……catch语句中finally语句也是一定要执行的。于是在这里就产生了麻烦。试了一下，发现果然是执行了finally中的值。正好这两天公司在培训，我便把这个问题提给java很厉害的一个讲师，他用断点测试了一下，说是两个值都返回了……   
我又改了一小下，在get方法中逐个添上了输出信息到控制台的语句，发现居然能执行。如下

1<img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" align="top" height="16" width="11" />public class test   
2 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
3 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />public static void main(String args[])   
4 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
5 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />test t = new test();   
6 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />int b = t.get();   
7 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />System.out.println(&#8220;Third: a = &#8220;+b);   
8 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
9 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />public int get()   
10 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
11 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />try   
12 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
13 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />System.out.println(&#8220;First: a = &#8220;+2);   
14 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />return 2;   
15 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
16 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />catch(Exception e)   
17 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
18 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />System.out.println(3);   
19 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
20 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />finally   
21 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" align="top" height="16" width="11" /> <img src="http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif" align="top" height="16" width="11" /><img src="http://www.blogjava.net/Images/dot.gif" height="20" width="15" />{   
22 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />System.out.println(&#8220;Second: a = &#8220;+4);   
23 <img src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" align="top" height="16" width="11" />return 4;   
24 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
25 <img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" align="top" height="16" width="11" />}   
26<img src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif" align="top" height="16" width="11" />}   
27<img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" align="top" height="16" width="11" />

输出：   
First: a = 2   
Second: a = 4   
Third: a = 4   
可这明明是一个需要返回一个int整数的方法啊。

[一道面试题目](http://www.blogjava.net/antsoul/archive/2007/03/17/104419.html)

一个整数，大于0，不用循环和本地变量，按照n，2n，4n，8n的顺序递增，当值大于5000时，把值按照指定顺序输出来。   
例：n=1237   
则输出为：   
1237，   
2474，   
4948，   
9896，   
9896，   
4948，   
2474，   
1237，

[美资软件公司JAVA工程师电话面试题目](http://www.blogjava.net/tendao/archive/2007/03/12/103355.html)

1. Talk about overriding, overloading.   
2. Talk about JAVA design patterns you known.   
3. Talk about the difference between LinkList, ArrayList and Victor.   
4. Talk about the difference between an Abstract class and an Interface.   
5. Class a = new Class(); Class b = new Class();   
if(a == b) returns true or false, why?   
6. Why we use StringBuffer when concatenating strings?   
7. Try to explain Singleton to us? Is it thread safe? If no, how to make it thread safe?   
8. Try to explain Ioc?   
9. How to set many-to-many relationship in Hibernate?   
10. Talk about the difference between INNER JOIN and LFET JOIN.   
11. Why we use index in database? How many indexes is the maximum in one table as your suggestion?   
12. When &#8216;Final&#8217; is used in class, method and property, what dose it mean?   
13. Do you have any experience on XML? Talk about any XML tool you used ,e.g. JAXB, JAXG.   
14. Do you have any experience on Linux?   
15. In OOD what is the reason when you create a Sequence diagram?

补一个内部培训用的 PPT: [SQL Tuning in Sybase.zip](http://www.blogjava.net/Files/beansoft/SQL Tuning in Sybase.zip) 17KB, 英文, Sybase 调优, 大部分道理是通用的.

数据库三范式是什么? 别看问题简单, 我也经常答不上来被面试的人写上数据库不行. 

还有就是 Sun Java 认证时候会考的一些英文选择题, 填空题, 模拟题也成.

[赴港JAVA开发工程师的面试题目](http://www.blogjava.net/tendao/archive/2007/03/18/104604.html)

也是上个星期五的上午，按照与猎头的约定，接受了香港某软件供应商的面试。工作是分析程序员，需赴港工作，以下是面试过程以及题目（大概记下了90%），记下来与大家分享。   
第一部分：例行公事的英文自我介绍；   
以下部分必须以粤语回答，本人非广东人，粤语会讲，但是不标准。   
第二部分：项目经验介绍，着重介绍项目背景，开发流程以及本人在项目开发过程中的角色；   
第三部分：面试官根据简历提问：   
(1)说出Abstract class与interface的不同？   
(2)Oracle中如何进行错误处理？如果用户反应速度慢，你如何着手解决问题？   
(3)图画板上列了两个table,问查询结果，主要是考inner join与left join的。   
(4)union和union all有什么不同?   
(5)你用什么软件做设计？   
(6)是否用过Websphere？   
(7)iBatis与Hibernate有什么不同?   
(8)谈谈Struts中的Action servlet。   
(9)是否开发过IBM portal项目。   
(10)是否介意加班?   
(11)如果你去香港工作，你认为你最大的困难是什么?   
第四部分：笔试，三个英文考试题目选一个作答，内容都是写一份email。   
出来后问了猎头，他说最迟一个星期内就有结果。   
结果，晚上就接到电话说通过了，并收到了合同和赴港申请的电子文件。工作地点是九龙，月薪18K（中等偏低），合同期一年。猎头催我尽快签合同，然后他们马上就去办工作签证。   
犹豫ing。

[每个JAVA初学者应该知道的问题](http://www.blogjava.net/SIDNEY/archive/2007/03/20/104864.html)

对于这个系列里的问题，每个学Java的人都应该搞懂。当然，如果只是学Java玩玩就无所谓了。如果你认为自己已经超越初学者了，却不很懂这些问题，请将你自己重归初学者行列。内容均来自于CSDN的经典老贴。   
问题一：我声明了什么！   
String s = &#8220;Hello world!&#8221;;   
许多人都做过这样的事情，但是，我们到底声明了什么？回答通常是：一个String，内容是&#8221;Hello world!&#8221;。这样模糊的回答通常是概念不清的根源。如果要准确的回答，一半的人大概会回答错误。   
这个语句声明的是一个指向对象的引用，名为&#8221;s&#8221;，可以指向类型为String的任何对象，目前指向&#8221;Hello world!&#8221;这个String类型的对象。这就是真正发生的事情。我们并没有声明一个String对象，我们只是声明了一个只能指向String对象的引用变量。所以，如果在刚才那句语句后面，如果再运行一句：   
String string = s;   
我们是声明了另外一个只能指向String对象的引用，名为string，并没有第二个对象产生，string还是指向原来那个对象，也就是，和s指向同一个对象。   
问题二：&#8221;==&#8221;和equals方法究竟有什么区别？   
==操作符专门用来比较变量的值是否相等。比较好理解的一点是：   
int a=10;   
int b=10;   
则a==b将是true。   
但不好理解的地方是：   
String a=new String(&#8220;foo&#8221;);   
String b=new String(&#8220;foo&#8221;);   
则a==b将返回false。   
根据前一帖说过，对象变量其实是一个引用，它们的值是指向对象所在的内存地址，而不是对象本身。a和b都使用了new操作符，意味着将在内存中产生两个内容为&#8221;foo&#8221;的字符串，既然是&#8221;两个&#8221;，它们自然位于不同的内存地址。a和b的值其实是两个不同的内存地址的值，所以使用&#8221;==&#8221;操作符，结果会是 false。诚然，a和b所指的对象，它们的内容都是&#8221;foo&#8221;，应该是&#8221;相等&#8221;，但是==操作符并不涉及到对象内容的比较。   
对象内容的比较，正是equals方法做的事。   
看一下Object对象的equals方法是如何实现的：   
boolean equals(Object o){   
return this==o;   
}   
Object 对象默认使用了==操作符。所以如果你自创的类没有覆盖equals方法，那你的类使用equals和使用==会得到同样的结果。同样也可以看出， Object的equals方法没有达到equals方法应该达到的目标：比较两个对象内容是否相等。因为答案应该由类的创建者决定，所以Object把这个任务留给了类的创建者。   
看一下一个极端的类：   
Class Monster{   
private String content;   
&#8230;   
boolean equals(Object another){ return true;}   
}   
我覆盖了equals方法。这个实现会导致无论Monster实例内容如何，它们之间的比较永远返回true。   
所以当你是用equals方法判断对象的内容是否相等，请不要想当然。因为可能你认为相等，而这个类的作者不这样认为，而类的equals方法的实现是由他掌握的。如果你需要使用equals方法，或者使用任何基于散列码的集合（HashSet,HashMap,HashTable），请察看一下 java doc以确认这个类的equals逻辑是如何实现的。   
问题三：String到底变了没有？   
没有。因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。请看下列代码：   
String s = &#8220;Hello&#8221;;   
s = s + &#8221; world!&#8221;;   
s 所指向的对象是否改变了呢？从本系列第一篇的结论很容易导出这个结论。我们来看看发生了什么事情。在这段代码中，s原先指向一个String对象，内容是 &#8220;Hello&#8221;，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为&#8221;Hello world!&#8221;，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。   
通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。   
同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：   
public class Demo {   
private String s;   
&#8230;   
public Demo {   
s = &#8220;Initial Value&#8221;;   
}   
&#8230;   
}   
而非   
s = new String(&#8220;Initial Value&#8221;);   
后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。   
上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。   
至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。   
问题四：final关键字到底修饰了什么？   
final使得被修饰的变量&#8221;不变&#8221;，但是由于对象型变量的本质是&#8221;引用&#8221;，使得&#8221;不变&#8221;也有了两种含义：引用本身的不变，和引用指向的对象不变。   
引用本身的不变：   
final StringBuffer a=new StringBuffer(&#8220;immutable&#8221;);   
final StringBuffer b=new StringBuffer(&#8220;not immutable&#8221;);   
a=b;//编译期错误   
引用指向的对象不变：   
final StringBuffer a=new StringBuffer(&#8220;immutable&#8221;);   
a.append(&#8221; broken!&#8221;); //编译通过   
可见，final只对引用的&#8221;值&#8221;(也即它所指向的那个对象的内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于它所指向的对象的变化，final是不负责的。这很类似==操作符：==操作符只负责引用的&#8221;值&#8221;相等，至于这个地址所指向的对象内容是否相等，==操作符是不管的。   
理解final问题有很重要的含义。许多程序漏洞都基于此&#8212;-final只能保证引用永远指向固定对象，不能保证那个对象的状态不变。在多线程的操作中,一个对象会被多个线程共享或修改，一个线程对对象无意识的修改可能会导致另一个使用此对象的线程崩溃。一个错误的解决方法就是在此对象新建的时候把它声明为final，意图使得它&#8221;永远不变&#8221;。其实那是徒劳的。   
问题五：到底要怎么样初始化！   
本问题讨论变量的初始化，所以先来看一下Java中有哪些种类的变量。   
1. 类的属性，或者叫值域   
2. 方法里的局部变量   
3. 方法的参数   
对于第一种变量，Java虚拟机会自动进行初始化。如果给出了初始值，则初始化为该初始值。如果没有给出，则把它初始化为该类型变量的默认初始值。   
int类型变量默认初始值为0   
float类型变量默认初始值为0.0f   
double类型变量默认初始值为0.0   
boolean类型变量默认初始值为false   
char类型变量默认初始值为0(ASCII码)   
long类型变量默认初始值为0   
所有对象引用类型变量默认初始值为null，即不指向任何对象。注意数组本身也是对象，所以没有初始化的数组引用在自动初始化后其值也是null。   
对于两种不同的类属性，static属性与instance属性，初始化的时机是不同的。instance属性在创建实例的时候初始化，static属性在类加载，也就是第一次用到这个类的时候初始化，对于后来的实例的创建，不再次进行初始化。这个问题会在以后的系列中进行详细讨论。   
对于第二种变量，必须明确地进行初始化。如果再没有初始化之前就试图使用它，编译器会抗议。如果初始化的语句在try块中或if块中，也必须要让它在第一次使用前一定能够得到赋值。也就是说，把初始化语句放在只有if块的条件判断语句中编译器也会抗议，因为执行的时候可能不符合if后面的判断条件，如此一来初始化语句就不会被执行了，这就违反了局部变量使用前必须初始化的规定。但如果在else块中也有初始化语句，就可以通过编译，因为无论如何，总有至少一条初始化语句会被执行，不会发生使用前未被初始化的事情。对于try-catch也是一样，如果只有在try块里才有初始化语句，编译部通过。如果在 catch或finally里也有，则可以通过编译。总之，要保证局部变量在使用之前一定被初始化了。所以，一个好的做法是在声明他们的时候就初始化他们，如果不知道要出事化成什么值好，就用上面的默认值吧！   
其实第三种变量和第二种本质上是一样的，都是方法中的局部变量。只不过作为参数，肯定是被初始化过的，传入的值就是初始值，所以不需要初始化。   
问题六：instanceof是什么东东？   
instanceof是Java的一个二元操作符，和==，>，<是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。举个例子：   
String s = &#8220;I AM an Object!&#8221;;   
boolean isObject = s instanceof Object;   
我们声明了一个String对象引用，指向一个String对象，然后用instancof来测试它所指向的对象是否是Object类的一个实例，显然，这是真的，所以返回true，也就是isObject的值为True。   
instanceof有一些用处。比如我们写了一个处理账单的系统，其中有这样三个类：   
public class Bill {//省略细节}   
public class PhoneBill extends Bill {//省略细节}   
public class GasBill extends Bill {//省略细节}   
在处理程序里有一个方法，接受一个Bill类型的对象，计算金额。假设两种账单计算方法不同，而传入的Bill对象可能是两种中的任何一种，所以要用instanceof来判断：   
public double calculate(Bill bill) {   
if (bill instanceof PhoneBill) {   
//计算电话账单   
}   
if (bill instanceof GasBill) {   
//计算燃气账单   
}   
&#8230;   
}   
这样就可以用一个方法处理两种子类。   
然而，这种做法通常被认为是没有好好利用面向对象中的多态性。其实上面的功能要求用方法重载完全可以实现，这是面向对象变成应有的做法，避免回到结构化编程模式。只要提供两个名字和返回值都相同，接受参数类型不同的方法就可以了：   
public double calculate(PhoneBill bill) {   
//计算电话账单   
}   
public double calculate(GasBill bill) {   
//计算燃气账单   
}   
所以，使用instanceof在绝大多数情况下并不是推荐的做法，应当好好利用多态。

BeanSoft 参加过的一次面试:

2004年8月18日 星期三 〖农历 甲申 猴年 七月初三〗

笔试题目   
1. 写出常用的 Linux 命令   
a) 列出当前目录   
b) 列出所有系统变量   
c) 重命名文件   
d) etc&#8230; 记不住了.

2. Write a Java application use the Singleton pattern, it should have one instance per class. It should have two integer variable, one is count, on is inita. There should be two methods in this class, and the method should be thread safely in multi-thread environment.   
a) a count() method, after each call the count should be added on by 1;   
b) a reset() method, after each call the count should be set to the value of inita.

3. Write a JavaBean and a JSP file. The page should output a date string in this pattern &#8220;今天是2004年8月15日上午10:00&#8221;, the value is taken from the bean.

4. 以下三个题目, 任选其一或多个:   
1) 忘了&#8230;, 是关于 Java 的.   
2) 写一个应用程序, 读出 STUDENT 表中的数据并打印出所有名称. 数据库系统任选.   
3) 写一个 Servlet, 读取名为 url 的参数, 并连接到此字符串指定的地址上, 读取所有内容后显示给客户.

5. 6. 7. 都是关于 SQL 的, 例如 SELECT, UPDATE, DELETE 之类的, 还有的有子查询. 数据库系统没有限制.

8. Write a html file, it shoud has follow functions:   
1) check whether the user&#8217;s name is empty;   
2) the email address should has a &#8216;@&#8217;;   
3) telephone number must be &#8216;1&#8217;-&#8216;9&#8217;, &#8216;-&#8216;, &#8216; &#8216;(space).   
Page picture:   
Please input your name:   
\[\___\___\___\___\___\_____\] \[Check input\]   
Please input your address:   
\[abc@\___\___\___\___\____\] \[Check input\]   
Please input your telephone number:   
\[_\_\\_\_123a\_\_\___\___\____\] \[Check input\]

**Java 面试题及其答案**

前段时间因为要参加一个笔试，在准备期间在网上找到了两条关于笔试题目的文章，其中一篇为<<有感:应聘Java笔试时可能出现问题>>，还有一篇忘了名字，读后深受启发。   
在寻找这些答案的过程中，我将相关答案记录下来，就形成了以下这些东西。需要说明的是以下答案肯定有很多不完整甚至错误的地方，需要各位来更正与完善它，千万不要扔我的鸡蛋啊。   
希望本文能够给即将奔赴笔试考场的同仁些许帮助，更希望更多的人加入到收集整理笔试题与完善答案的这些工作中来，为大家更好的获得工作机会做一点贡献。   
在此感谢前面两文的作者的对笔试题目的收集与整理。   
如有任何意见与建议请通过QQ:6045306,Mail:huijunzi@21cn.com与我联系。   
Java基础方面:

1、作用域public,private,protected,以及不写时的区别   
答：区别如下：   
作用域 当前类 同一package 子孙类 其他package   
public √ √ √ √   
protected √ √ √ ×   
friendly √ √ × ×   
private √ × × ×   
不写时默认为friendly

2、ArrayList和Vector的区别,HashMap和Hashtable的区别   
答：就ArrayList与Vector主要从二方面来说.   
一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的   
二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半   
就HashMap与HashTable主要从三方面来说。   
一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现   
二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的   
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value

3、char型变量中能不能存贮一个中文汉字?为什么?   
答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的

4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?   
答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口   
同步的实现方面有两种，分别是synchronized,wait与notify

5、继承时候类的执行顺序问题,一般都是选择题,问你将会打印出什么?   
答:父类：   
package test;   
public class FatherClass   
{   
public FatherClass()   
{   
System.out.println(&#8220;FatherClass Create&#8221;);   
}   
}   
子类:   
package test;   
import test.FatherClass;   
public class ChildClass extends FatherClass   
{   
public ChildClass()   
{   
System.out.println(&#8220;ChildClass Create&#8221;);   
}   
public static void main(String[] args)   
{   
FatherClass fc = new FatherClass();   
ChildClass cc = new ChildClass();   
}   
}   
输出结果：   
C:\>java test.ChildClass   
FatherClass Create   
FatherClass Create   
ChildClass Create

6、内部类的实现方式?   
答：示例代码如下：   
package test;   
public class OuterClass   
{   
private class InterClass   
{   
public InterClass()   
{   
System.out.println(&#8220;InterClass Create&#8221;);   
}   
}   
public OuterClass()   
{   
InterClass ic = new InterClass();   
System.out.println(&#8220;OuterClass Create&#8221;);   
}   
public static void main(String[] args)   
{   
OuterClass oc = new OuterClass();   
}   
}   
输出结果:   
C:\>java test/OuterClass   
InterClass Create   
OuterClass Create   
再一个例题：   
public class OuterClass {   
private double d1 = 1.0;   
//insert code here   
}   
You need to insert an inner class declaration at line 3. Which two inner class declarations are

valid?(Choose two.)   
A. class InnerOne{   
public static double methoda() {return d1;}   
}   
B. public class InnerOne{   
static double methoda() {return d1;}   
}   
C. private class InnerOne{   
double methoda() {return d1;}   
}   
D. static class InnerOne{   
protected double methoda() {return d1;}   
}   
E. abstract class InnerOne{   
public abstract double methoda();   
}   
说明如下：   
一.静态内部类可以有静态成员，而非静态内部类则不能有静态成员。 故 A、B 错   
二.静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量；return d1 出错。

故 D 错   
三.非静态内部类的非静态成员可以访问外部类的非静态变量。 故 C 正确   
四.答案为C、E

7、垃圾回收机制,如何优化程序?   
希望大家补上，谢谢

8、float型float f=3.4是否正确?   
答:不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4

9、介绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)?   
答：Collection FrameWork如下：   
Collection   
├List   
│├LinkedList   
│├ArrayList   
│└Vector   
│ └Stack   
└Set   
Map   
├Hashtable   
├HashMap   
└WeakHashMap   
Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）   
Map提供key到value的映射

10、Java中异常处理机制，事件机制？

11、JAVA中的多形与继承？   
希望大家补上，谢谢

12、抽象类与接口？   
答：抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。

13、Java 的通信编程，编程题(或问答)，用JAVA SOCKET编程，读服务器几个字符，再写入本地显示？   
答:Server端程序:   
package test;   
import java.net.*;   
import java.io.*;

public class Server   
{   
private ServerSocket ss;   
private Socket socket;   
private BufferedReader in;   
private PrintWriter out;   
public Server()   
{   
try   
{   
ss=new ServerSocket(10000);   
while(true)   
{   
socket = ss.accept();   
String RemoteIP = socket.getInetAddress().getHostAddress();   
String RemotePort = &#8220;:&#8221;+socket.getLocalPort();   
System.out.println(&#8220;A client come in!IP:&#8221;+RemoteIP+RemotePort);   
in = new BufferedReader(new

InputStreamReader(socket.getInputStream()));   
String line = in.readLine();   
System.out.println(&#8220;Cleint send is :&#8221; + line);   
out = new PrintWriter(socket.getOutputStream(),true);   
out.println(&#8220;Your Message Received!&#8221;);   
out.close();   
in.close();   
socket.close();   
}   
}catch (IOException e)   
{   
out.println(&#8220;wrong&#8221;);   
}   
}   
public static void main(String[] args)   
{   
new Server();   
}   
};   
Client端程序:   
package test;   
import java.io.*;   
import java.net.*;

public class Client   
{   
Socket socket;   
BufferedReader in;   
PrintWriter out;   
public Client()   
{   
try   
{   
System.out.println(&#8220;Try to Connect to 127.0.0.1:10000&#8221;);   
socket = new Socket(&#8220;127.0.0.1&#8221;,10000);   
System.out.println(&#8220;The Server Connected!&#8221;);   
System.out.println(&#8220;Please enter some Character:&#8221;);   
BufferedReader line = new BufferedReader(new

InputStreamReader(System.in));   
out = new PrintWriter(socket.getOutputStream(),true);   
out.println(line.readLine());   
in = new BufferedReader(new InputStreamReader(socket.getInputStream()));   
System.out.println(in.readLine());   
out.close();   
in.close();   
socket.close();   
}catch(IOException e)   
{   
out.println(&#8220;Wrong&#8221;);   
}   
}   
public static void main(String[] args)   
{   
new Client();   
}   
};

14、用JAVA实现一种排序，JAVA类实现序列化的方法(二种)？ 如在COLLECTION框架中，实现比较要实现什么样的接口？   
答:用插入法进行排序代码如下   
package test;   
import java.util.*;   
class InsertSort   
{   
ArrayList al;   
public InsertSort(int num,int mod)   
{   
al = new ArrayList(num);   
Random rand = new Random();   
System.out.println(&#8220;The ArrayList Sort Before:&#8221;);   
for (int i=0;i<num ;i++ )   
{   
al.add(new Integer(Math.abs(rand.nextInt()) % mod + 1));   
System.out.println(&#8220;al[&#8220;+i+&#8221;]=&#8221;+al.get(i));   
}   
}   
public void SortIt()   
{   
Integer tempInt;   
int MaxSize=1;   
for(int i=1;i<al.size();i++)   
{   
tempInt = (Integer)al.remove(i);   
if(tempInt.intValue()>=((Integer)al.get(MaxSize-1)).intValue())   
{   
al.add(MaxSize,tempInt);   
MaxSize++;   
System.out.println(al.toString());   
} else {   
for (int j=0;j<MaxSize ;j++ )   
{   
if

(((Integer)al.get(j)).intValue()>=tempInt.intValue())   
{   
al.add(j,tempInt);   
MaxSize++;   
System.out.println(al.toString());   
break;   
}   
}   
}   
}   
System.out.println(&#8220;The ArrayList Sort After:&#8221;);   
for(int i=0;i<al.size();i++)   
{   
System.out.println(&#8220;al[&#8220;+i+&#8221;]=&#8221;+al.get(i));   
}   
}   
public static void main(String[] args)   
{   
InsertSort is = new InsertSort(10,100);   
is.SortIt();   
}   
}   
JAVA类实现序例化的方法是实现java.io.Serializable接口   
Collection框架中实现比较要实现Comparable 接口和 Comparator 接口

15、编程：编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如&#8221;我ABC&#8221;4，应该截为&#8221;我AB&#8221;，输入&#8221;我ABC汉DEF&#8221;，6，应该输出为&#8221;我ABC&#8221;而不是&#8221;我ABC+汉的半个&#8221;。   
答：代码如下：   
package test;

class SplitString   
{   
String SplitStr;   
int SplitByte;   
public SplitString(String str,int bytes)   
{   
SplitStr=str;   
SplitByte=bytes;   
System.out.println(&#8220;The String is:′&#8221;+SplitStr+&#8221;′SplitBytes=&#8221;+SplitByte);   
}   
public void SplitIt()   
{   
int loopCount;

loopCount=(SplitStr.length()%SplitByte==0)?(SplitStr.length()/SplitByte):(SplitStr.length()/Split

Byte+1);   
System.out.println(&#8220;Will Split into &#8220;+loopCount);   
for (int i=1;i<=loopCount ;i++ )   
{   
if (i==loopCount){

System.out.println(SplitStr.substring((i-1)*SplitByte,SplitStr.length()));   
} else {

System.out.println(SplitStr.substring((i-1)\*SplitByte,(i\*SplitByte)));   
}   
}   
}   
public static void main(String[] args)   
{   
SplitString ss = new SplitString(&#8220;test中dd文dsaf中男大3443n中国43中国人

0ewldfls=103&#8243;,4);   
ss.SplitIt();   
}   
}

16、JAVA多线程编程。 用JAVA写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出。   
希望大家补上，谢谢

17、STRING与STRINGBUFFER的区别。   
答：STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法

Jsp方面

1、jsp有哪些内置对象?作用分别是什么?   
答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：   
request 用户端请求，此请求会包含来自GET/POST请求的参数   
response 网页传回用户端的回应   
pageContext 网页的属性是在这里管理   
session 与请求有关的会话期   
application servlet 正在执行的内容   
out 用来传送回应的输出   
config servlet的构架部件   
page JSP网页本身   
exception 针对错误网页，未捕捉的例外

2、jsp有哪些动作?作用分别是什么?   
答:JSP共有以下6种基本动作   
jsp:include：在页面被请求的时候引入一个文件。   
jsp:useBean：寻找或者实例化一个JavaBean。   
jsp:setProperty：设置JavaBean的属性。   
jsp:getProperty：输出某个JavaBean的属性。   
jsp:forward：把请求转到一个新的页面。   
jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记

3、JSP中动态INCLUDE与静态INCLUDE的区别？   
答：动态INCLUDE用jsp:include动作实现   
<jsp:include page=&#8221;included.jsp&#8221; flush=&#8221;true&#8221; />它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数   
静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面   
<%@ include file=&#8221;included.htm&#8221; %>

4、两种跳转方式分别是什么?有什么区别?   
答：有两种，分别为：   
<jsp:include page=&#8221;included.jsp&#8221; flush=&#8221;true&#8221;>   
<jsp:forward page= &#8220;nextpage.jsp&#8221;/>   
前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。

Servlet方面

1、说一说Servlet的生命周期?   
答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。

2、Servlet版本间(忘了问的是哪两个版本了)的不同?   
希望大家补上，谢谢

3、JAVA SERVLET API中forward() 与redirect()的区别？   
答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。

4、Servlet的基本架构   
public class ServletName extends HttpServlet {   
public void doPost(HttpServletRequest request, HttpServletResponse response) throws   
ServletException, IOException {   
}   
public void doGet(HttpServletRequest request, HttpServletResponse response) throws   
ServletException, IOException {   
}   
}

Jdbc、Jdo方面

1、可能会让你写一段Jdbc连Oracle的程序,并实现数据查询.   
答:程序如下：   
package hello.ant;   
import java.sql.*;   
public class jdbc   
{   
String dbUrl=&#8221;jdbc:oracle:thin:@127.0.0.1:1521:orcl&#8221;   
String theUser=&#8221;admin&#8221;   
String thePw=&#8221;manager&#8221;   
Connection c=null;   
Statement conn;   
ResultSet rs=null;   
public jdbc()   
{   
try{   
Class.forName(&#8220;oracle.jdbc.driver.OracleDriver&#8221;).newInstance();   
c = DriverManager.getConnection(dbUrl,theUser,thePw);   
conn=c.createStatement();   
}catch(Exception e){   
e.printStackTrace();   
}   
}   
public boolean executeUpdate(String sql)   
{   
try   
{   
conn.executeUpdate(sql);   
return true;   
}   
catch (SQLException e)   
{   
e.printStackTrace();   
return false;   
}   
}   
public ResultSet executeQuery(String sql)   
{   
rs=null;   
try   
{   
rs=conn.executeQuery(sql);   
}   
catch (SQLException e)   
{   
e.printStackTrace();   
}   
return rs;   
}   
public void close()   
{   
try   
{   
conn.close();   
c.close();   
}   
catch (Exception e)   
{   
e.printStackTrace();   
}   
}   
public static void main(String[] args)   
{   
ResultSet rs;   
jdbc conn = new jdbc();   
rs=conn.executeQuery(&#8220;select * from test&#8221;);   
try{   
while (rs.next())   
{   
System.out.println(rs.getString(&#8220;id&#8221;));   
System.out.println(rs.getString(&#8220;name&#8221;));   
}   
}catch(Exception e)   
{   
e.printStackTrace();   
}   
}   
}

2、Class.forName的作用?为什么要用?   
答：调用该访问返回一个以字符串指定类名的类的对象。

3、Jdo是什么?   
答:JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。

4、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法。   
答:一种分页方法   
<%   
int i=1;   
int numPages=14;   
String pages = request.getParameter(&#8220;page&#8221;) ;   
int currentPage = 1;   
currentPage=(pages==null)?(1):{Integer.parseInt(pages)}   
sql = &#8220;select count(*) from tables&#8221;   
ResultSet rs = DBLink.executeQuery(sql) ;   
while(rs.next()) i = rs.getInt(1) ;   
int intPageCount=1;   
intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1);   
int nextPage ;   
int upPage;   
nextPage = currentPage+1;   
if (nextPage>=intPageCount) nextPage=intPageCount;   
upPage = currentPage-1;   
if (upPage<=1) upPage=1;   
rs.close();   
sql=&#8221;select * from tables&#8221;   
rs=DBLink.executeQuery(sql);   
i=0;   
while((i<numPages*(currentPage-1))&&rs.next()){i++;}   
%>   
//输出内容   
//输出翻页连接   
合计:<%=currentPage%>/<%=intPageCount%><a href=&#8221;List.jsp?page=1&#8243;>第一页</a><a

href=&#8221;List.jsp?page=<%=upPage%>&#8221;>上一页</a>   
<%   
for(int j=1;j<=intPageCount;j++){   
if(currentPage!=j){   
%>   
<a href=&#8221;list.jsp?page=<%=j%>&#8221;>[<%=j%>]</a>   
<%   
}else{   
out.println(j);   
}   
}   
%>   
<a href=&#8221;List.jsp?page=<%=nextPage%>&#8221;>下一页</a><a href=&#8221;List.jsp?page=<%=intPageCount%>&#8221;>最后页

</a>

Xml方面

1、xml有哪些解析技术?区别是什么?   
答:有DOM,SAX,STAX等   
DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问   
STAX:Streaming API for XML (StAX)

2、你在项目中用到了xml技术的哪些方面?如何实现的?   
答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。

3、用jdom解析xml文件时如何解决中文问题?如何解析?   
答:看如下代码,用编码方式加以解决   
package test;   
import java.io.*;   
public class DOMTest   
{   
private String inFile = &#8220;c:\\people.xml&#8221;   
private String outFile = &#8220;c:\\people.xml&#8221;   
public static void main(String args[])   
{   
new DOMTest();   
}   
public DOMTest()   
{   
try   
{   
javax.xml.parsers.DocumentBuilder builder =

javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();   
org.w3c.dom.Document doc = builder.newDocument();   
org.w3c.dom.Element root = doc.createElement(&#8220;老师&#8221;);   
org.w3c.dom.Element wang = doc.createElement(&#8220;王&#8221;);   
org.w3c.dom.Element liu = doc.createElement(&#8220;刘&#8221;);   
wang.appendChild(doc.createTextNode(&#8220;我是王老师&#8221;));   
root.appendChild(wang);   
doc.appendChild(root);   
javax.xml.transform.Transformer transformer =   
javax.xml.transform.TransformerFactory.newInstance().newTransformer();   
transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, &#8220;gb2312&#8221;);   
transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, &#8220;yes&#8221;);

transformer.transform(new javax.xml.transform.dom.DOMSource(doc),   
new

javax.xml.transform.stream.StreamResult(outFile));   
}   
catch (Exception e)   
{   
System.out.println (e.getMessage());   
}   
}   
}

4、编程用JAVA解析XML的方式.   
答:用SAX方式解析XML，XML文件如下：   
<?xml version=&#8221;1.0&#8243; encoding=&#8221;gb2312&#8243;?>   
<person>   
<name>王小明</name>   
<college>信息学院</college>   
<telephone>6258113</telephone>   
<notes>男,1955年生,博士，95年调入海南大学</notes>   
</person>   
事件回调类SAXHandler.java   
import java.io.*;   
import java.util.Hashtable;   
import org.xml.sax.*;   
public class SAXHandler extends HandlerBase   
{   
private Hashtable table = new Hashtable();   
private String currentElement = null;   
private String currentValue = null;   
public void setTable(Hashtable table)   
{   
this.table = table;   
}   
public Hashtable getTable()   
{   
return table;   
}   
public void startElement(String tag, AttributeList attrs)   
throws SAXException   
{   
currentElement = tag;   
}   
public void characters(char[] ch, int start, int length)   
throws SAXException   
{   
currentValue = new String(ch, start, length);   
}   
public void endElement(String name) throws SAXException   
{   
if (currentElement.equals(name))   
table.put(currentElement, currentValue);   
}   
}   
JSP内容显示源码,SaxXml.jsp:   
<HTML>   
<HEAD>   
<TITLE>剖析XML文件people.xml</TITLE>   
</HEAD>   
<BODY>   
<%@ page errorPage=&#8221;ErrPage.jsp&#8221;   
contentType=&#8221;text/html;charset=GB2312&#8243; %>   
<%@ page import=&#8221;java.io.*&#8221; %>   
<%@ page import=&#8221;java.util.Hashtable&#8221; %>   
<%@ page import=&#8221;org.w3c.dom.*&#8221; %>   
<%@ page import=&#8221;org.xml.sax.*&#8221; %>   
<%@ page import=&#8221;javax.xml.parsers.SAXParserFactory&#8221; %>   
<%@ page import=&#8221;javax.xml.parsers.SAXParser&#8221; %>   
<%@ page import=&#8221;SAXHandler&#8221; %>   
<%   
File file = new File(&#8220;c:\\people.xml&#8221;);   
FileReader reader = new FileReader(file);   
Parser parser;   
SAXParserFactory spf = SAXParserFactory.newInstance();   
SAXParser sp = spf.newSAXParser();   
SAXHandler handler = new SAXHandler();   
sp.parse(new InputSource(reader), handler);   
Hashtable hashTable = handler.getTable();   
out.println(&#8220;<TABLE BORDER=2><CAPTION>教师信息表</CAPTION>&#8221;);   
out.println(&#8220;<TR><TD>姓名</TD>&#8221; + &#8220;<TD>&#8221; +   
(String)hashTable.get(new String(&#8220;name&#8221;)) + &#8220;</TD></TR>&#8221;);   
out.println(&#8220;<TR><TD>学院</TD>&#8221; + &#8220;<TD>&#8221; +   
(String)hashTable.get(new String(&#8220;college&#8221;))+&#8221;</TD></TR>&#8221;);   
out.println(&#8220;<TR><TD>电话</TD>&#8221; + &#8220;<TD>&#8221; +   
(String)hashTable.get(new String(&#8220;telephone&#8221;)) + &#8220;</TD></TR>&#8221;);   
out.println(&#8220;<TR><TD>备注</TD>&#8221; + &#8220;<TD>&#8221; +   
(String)hashTable.get(new String(&#8220;notes&#8221;)) + &#8220;</TD></TR>&#8221;);   
out.println(&#8220;</TABLE>&#8221;);   
%>   
</BODY>   
</HTML>

EJB方面

1、EJB2.0有哪些内容?分别用在什么场合? EJB2.0和EJB1.1的区别?   
答：规范内容包括Bean提供者，应用程序装配者，EJB容器，EJB配置工具，EJB服务提供者，系统管理员。这里面，EJB容器是EJB之所以能够运行的核心。EJB容器管理着EJB的创建，撤消，激活，去活，与数据库的连接等等重要的核心工作。JSP,Servlet,EJB,JNDI,JDBC,JMS&#8230;..

2、EJB与JAVA BEAN的区别？   
答:Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。

3、EJB的基本架构   
答:一个EJB包括三个部分:   
Remote Interface 接口的代码   
package Beans;   
import javax.ejb.EJBObject;   
import java.rmi.RemoteException;   
public interface Add extends EJBObject   
{   
//some method declare   
}   
Home Interface 接口的代码   
package Beans;   
import java.rmi.RemoteException;   
import jaax.ejb.CreateException;   
import javax.ejb.EJBHome;   
public interface AddHome extends EJBHome   
{   
//some method declare   
}   
EJB类的代码   
package Beans;   
import java.rmi.RemoteException;   
import javax.ejb.SessionBean;   
import javx.ejb.SessionContext;   
public class AddBean Implements SessionBean   
{   
//some method declare   
}

J2EE,MVC方面

1、MVC的各个部分都有那些技术来实现?如何实现?   
答:MVC是Model－View－Controller的简写。&#8221;Model&#8221; 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， &#8220;View&#8221; 是应用的表示面（由JSP页面产生），&#8221;Controller&#8221; 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。

2、应用服务器与WEB SERVER的区别？   
希望大家补上，谢谢

3、J2EE是什么？   
答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。

4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。   
答：Web Service描述语言WSDL   
SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。   
UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。

5、BS与CS的联系与区别。   
希望大家补上，谢谢

6、STRUTS的应用(如STRUTS架构)   
答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能：   
一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。   
二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。   
三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。

设计模式方面

1、开发中都用到了那些设计模式?用在什么场合?   
答：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。

2、UML方面   
答：标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图,

JavaScript方面

1、如何校验数字型?   
var re=/^\d{1,8}$|\.\d{1,2}$/;   
var str=document.form1.all(i).value;   
var r=str.match(re);   
if (r==null)   
{   
sign=-4;   
break;   
}   
else{   
document.form1.all(i).value=parseFloat(str);   
}

CORBA方面

1、CORBA是什么?用途是什么?   
答：CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：   
用不同的程序设计语言书写   
在不同的进程中运行   
为不同的操作系统开发

LINUX方面

1、LINUX下线程，GDI类的解释。   
答：LINUX实现的就是基于核心轻量级进程的&#8221;一对一&#8221;线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。   
GDI类为图像设备编程接口类库。

转载请注明：[WebLogic Android 博客](http://www.beansoft.biz) &raquo; [面试时候经常会问的一些问题(不断补充中)](http://www.beansoft.biz/2010/08/02/%e9%9d%a2%e8%af%95%e6%97%b6%e5%80%99%e7%bb%8f%e5%b8%b8%e4%bc%9a%e9%97%ae%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98%e4%b8%8d%e6%96%ad%e8%a1%a5%e5%85%85%e4%b8%ad/)